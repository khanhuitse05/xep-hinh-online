package Server;

import java.net.InetSocketAddress;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import org.jboss.netty.bootstrap.ServerBootstrap;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelFactory;
import org.jboss.netty.channel.group.ChannelGroup;
import org.jboss.netty.channel.group.DefaultChannelGroup;
import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;
import org.jboss.netty.handler.execution.OrderedMemoryAwareThreadPoolExecutor;

public class SocketServer 
{
	public static void main(String[] args) throws Exception
	{  
		
		 // Configure the server.
        ServerBootstrap bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(Executors.newCachedThreadPool(), Executors.newCachedThreadPool()));

        // Set up the pipeline factory.
        int threadPoolSize = Runtime.getRuntime().availableProcessors() << 3; // 8x
        long globalMemLimit = Runtime.getRuntime().maxMemory() >> 2;
        ChannelPipeline pipeline = bootstrap.getPipeline();
        pipeline.addLast("executor",
                            new ExecutionHandler
                            (
                                new OrderedMemoryAwareThreadPoolExecutor
                                (
                                    threadPoolSize,
                                    SERVER_CHANNEL_MEMORY_LIMIT,
                                    globalMemLimit,
                                    0, TimeUnit.MILLISECONDS
                                )
                            )
                        );
        pipeline.addLast("decoder", new SocketServerDecoder());
        pipeline.addLast("handler", new SocketServerHandler());

        //tcp option
        bootstrap.setOption("child.keepAlive", true);
        bootstrap.setOption("child.tcpNoDelay", true);
        bootstrap.setOption("child.reuseAddress", true);  
        bootstrap.setOption("child.connectTimeoutMillis", 100);  
        bootstrap.setOption("readWriteFair", true);  
        
        
        // Bind and start to accept incoming connections.
        s_strIPAddress  = isa.getHostName();
        s_nPort         = isa.getPort();
        bootstrap.bind(new InetSocketAddress(s_strIPAddress, s_nPort));
	}
        int port = 8080;
        int nbconn = Integer.parseInt(args[1]);  
  
        // *** Start the Netty configuration ***  
  
        // Start server with Nb of active threads = 2*NB CPU + 1 as maximum.  
        ChannelFactory factory = new NioServerSocketChannelFactory(Executors  
                .newCachedThreadPool(), Executors.newCachedThreadPool(),  
                Runtime.getRuntime().availableProcessors() * 2 + 1);  
  
        ServerBootstrap bootstrap = new ServerBootstrap(factory);  
        // Create the global ChannelGroup  
        ChannelGroup channelGroup = new DefaultChannelGroup(  
                PongSerializeServer.class.getName());  
        // Create the blockingQueue to wait for a limited number of client  
        BlockingQueue<Integer> answer = new LinkedBlockingQueue<Integer>();  
        // 200 threads max, Memory limitation: 1MB by channel, 1GB global, 100 ms of timeout  
        OrderedMemoryAwareThreadPoolExecutor pipelineExecutor = new OrderedMemoryAwareThreadPoolExecutor(  
                200, 1048576, 1073741824, 100, TimeUnit.MILLISECONDS, Executors  
                        .defaultThreadFactory());  
  
        bootstrap.setPipelineFactory(new PongPipelineFactory(channelGroup,  
                pipelineExecutor, answer, nbconn));  
        bootstrap.setOption("child.tcpNoDelay", true);  
        bootstrap.setOption("child.keepAlive", true);  
        bootstrap.setOption("child.reuseAddress", true);  
        bootstrap.setOption("child.connectTimeoutMillis", 100);  
        bootstrap.setOption("readWriteFair", true);  
  
        // *** Start the Netty running ***  
  
        // Create the monitor  
        ThroughputMonitor monitor = new ThroughputMonitor();  
        // Add the parent channel to the group  
        Channel channel = bootstrap.bind(new InetSocketAddress(port));  
        channelGroup.add(channel);  
  
        // Starts the monitor  
        monitor.start();  
  
        // Wait for the server to stop  
        answer.take();  
  
        // *** Start the Netty shutdown ***  
  
        // End the monitor  
        System.out.println("End of monitor");  
        monitor.interrupt();  
        // Now close all channels  
        System.out.println("End of channel group");  
        channelGroup.close().awaitUninterruptibly();  
        // Close the executor for Pipeline  
        System.out.println("End of pipeline executor");  
        pipelineExecutor.shutdownNow();  
        // Now release resources  
        System.out.println("End of resources");  
        factory.releaseExternalResources();  
}
